\documentclass{article}

\usepackage[english]{babel}

\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{ARMv8 AArch64 – Emulator \\
       \large Interim Checkpoint Report - Group 25}
\author{
        Bogdan Gavra \\
        Michał Andryskowski\\
        Jakub Łapiński\\
        Vlad Marchis\\\\
        Mentor: 
        Matthew Baugh
        }

\begin{document}
\maketitle

\section{Task distribution and communication}


The tasks were distributed in the first meeting in the HXLY-Labs, during which the main class and control class were implemented.
Afterward, each of the members chose a type of instruction (Direct processing Immediate, Direct Processing Register, Shifts, Branch Instruction, Standard Data Transfer) and it was decided that whoever finished their task's implementation first (including testing) would then continue work on the final Special Instructions.

Communication between the team members was achieved through a dedicated WhatsApp group chat. However, verbal communication played a vital role as most of the work was completed during physical team meetings.

\section{Reflection on our teamwork}

To prevent code duplication and ensure a continuous workflow, the first meeting was focused on the development of a skeleton on which instruction implementations could be added independently by team members. This approach proved advantageous and encouraged everyone to abstract out their code, opting for a more modular structuring, and writing general utility functions that could be used throughout the project. Furthermore, it allowed for a quick linking process between files and few errors during compilation and merging branches.

A test-driven development approach was adopted in which members chose a specific category of tests (usually the ones relating to the instructions they have implemented) and focused solely on passing them. In many cases, this required finding bugs in other group members' implementations, which gave us a higher-level understanding of our code base. During this period everyone had a chance to review each others' code, provide solutions and suggest refactoring options.

The recent days' effective and fast-paced workflow led to a rushed approach for the assembler. The time spent on discussing and creating the skeleton was little and members started their designated tasks almost immediately. Consequently, some poor design choices were made, notably the instruction type was checked twice (in control, to call the function and then again by the callee to perform the correct operation). Therefore, in order to prevent this problem from arising again, greater time was dedicated to building the skeleton for the extension.   

\section{Project structure}

\subsection{Emulator}
The initial structure of the project consisted of 5 main parts: the main file, the controller, the computer state, the multiple types of instruction files, and the output file generator, all files having their corresponding header file.\\

The program was organized such that, upon running the executable, the following steps would be run:
\begin{enumerate}
    \item The computer state, which contains an array representing the memory, the registers, as well as the flags, and the program counter is initialized.
    \item The main function then parses the input file, splitting it into 32-bit chunks.
    \item The controller would then be called for each of these chunks, matching them with a bit pattern that would indicate the instruction type.
    \item The corresponding function (eg. ExecuteBranch) modifies the computer state according to the instruction bit-mask provided.
    \item This aforementioned process repeats until the halt instruction (and x0, x0, x0) is reached, after which the output file is generated based on the final computer state.
    
\end{enumerate}

The final hours were spent on refactoring the code. Previously, all the files were in the \textbf{/src} directory, and all the utility functions were stored in the control file making it hard to read through. Sub-directories representing instructions and general files were created, while the utility functions were moved to a separate file (\textbf{utility.c/h}) under the \textbf{/util} directory.

\subsection{Assembler}
When implementing the assembler, some of the utility functions (mostly the ones handling bitwise manipulation) and the structure of the emulator (Main file, Controller, Instruction files) were reused. The way in which the assembler was coded did not allow for previously built (emulator) functions to be reused. Nonetheless, the assembler code turned out more concise and readable after making use of enums defining instruction types.

\section{Final reflection and future worries}
Overall, we are very pleased with how the team worked together, as everybody was aware of their duties as well as deadlines, so there was no conflict regarding somebody doing less work than the others.
In the current state of the project, we are working on the extension, and due to the fact that its development is still in the initial stages, we feel a bit overwhelmed with how much work needs to be done. Despite all that, given that the extension is something that makes use of each of the team members' previous knowledge and expertise, it is something that we enjoy doing, and are looking forward to seeing how the final version will come together.

\end{document}
